// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: rpc.proto
#ifndef GRPC_rpc_2eproto__INCLUDED
#define GRPC_rpc_2eproto__INCLUDED

#include "rpc.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

// rpc
class RPC final {
 public:
  static constexpr char const* service_full_name() {
    return "RPC";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status setup(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::SetupResponseMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetupResponseMessage>> Asyncsetup(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetupResponseMessage>>(AsyncsetupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetupResponseMessage>> PrepareAsyncsetup(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SetupResponseMessage>>(PrepareAsyncsetupRaw(context, request, cq));
    }
    virtual ::grpc::Status search(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::SearchResponseMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SearchResponseMessage>> Asyncsearch(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SearchResponseMessage>>(AsyncsearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SearchResponseMessage>> PrepareAsyncsearch(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SearchResponseMessage>>(PrepareAsyncsearchRaw(context, request, cq));
    }
    virtual ::grpc::Status add_data(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::AddResponseMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AddResponseMessage>> Asyncadd_data(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AddResponseMessage>>(Asyncadd_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AddResponseMessage>> PrepareAsyncadd_data(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AddResponseMessage>>(PrepareAsyncadd_dataRaw(context, request, cq));
    }
    virtual ::grpc::Status delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::DeleteResponseMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DeleteResponseMessage>> Asyncdelete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DeleteResponseMessage>>(Asyncdelete_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DeleteResponseMessage>> PrepareAsyncdelete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DeleteResponseMessage>>(PrepareAsyncdelete_dataRaw(context, request, cq));
    }
    virtual ::grpc::Status show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::ShowAllResponseMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ShowAllResponseMessage>> Asyncshow_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ShowAllResponseMessage>>(Asyncshow_allRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ShowAllResponseMessage>> PrepareAsyncshow_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ShowAllResponseMessage>>(PrepareAsyncshow_allRaw(context, request, cq));
    }
    virtual ::grpc::Status RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::RandomGenerateDBResponseMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RandomGenerateDBResponseMessage>> AsyncRanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RandomGenerateDBResponseMessage>>(AsyncRanGenDBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RandomGenerateDBResponseMessage>> PrepareAsyncRanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RandomGenerateDBResponseMessage>>(PrepareAsyncRanGenDBRaw(context, request, cq));
    }
    virtual ::grpc::Status DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::DestroyResponseMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DestroyResponseMessage>> AsyncDestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DestroyResponseMessage>>(AsyncDestroyDBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DestroyResponseMessage>> PrepareAsyncDestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DestroyResponseMessage>>(PrepareAsyncDestroyDBRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void setup(::grpc::ClientContext* context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setup(::grpc::ClientContext* context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setup(::grpc::ClientContext* context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void search(::grpc::ClientContext* context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void search(::grpc::ClientContext* context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void search(::grpc::ClientContext* context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void add_data(::grpc::ClientContext* context, const ::AddRequestMessage* request, ::AddResponseMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void add_data(::grpc::ClientContext* context, const ::AddRequestMessage* request, ::AddResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void add_data(::grpc::ClientContext* context, const ::AddRequestMessage* request, ::AddResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SetupResponseMessage>* AsyncsetupRaw(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SetupResponseMessage>* PrepareAsyncsetupRaw(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SearchResponseMessage>* AsyncsearchRaw(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SearchResponseMessage>* PrepareAsyncsearchRaw(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AddResponseMessage>* Asyncadd_dataRaw(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AddResponseMessage>* PrepareAsyncadd_dataRaw(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DeleteResponseMessage>* Asyncdelete_dataRaw(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DeleteResponseMessage>* PrepareAsyncdelete_dataRaw(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ShowAllResponseMessage>* Asyncshow_allRaw(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ShowAllResponseMessage>* PrepareAsyncshow_allRaw(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RandomGenerateDBResponseMessage>* AsyncRanGenDBRaw(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RandomGenerateDBResponseMessage>* PrepareAsyncRanGenDBRaw(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DestroyResponseMessage>* AsyncDestroyDBRaw(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DestroyResponseMessage>* PrepareAsyncDestroyDBRaw(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status setup(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::SetupResponseMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetupResponseMessage>> Asyncsetup(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetupResponseMessage>>(AsyncsetupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetupResponseMessage>> PrepareAsyncsetup(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SetupResponseMessage>>(PrepareAsyncsetupRaw(context, request, cq));
    }
    ::grpc::Status search(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::SearchResponseMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SearchResponseMessage>> Asyncsearch(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SearchResponseMessage>>(AsyncsearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SearchResponseMessage>> PrepareAsyncsearch(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SearchResponseMessage>>(PrepareAsyncsearchRaw(context, request, cq));
    }
    ::grpc::Status add_data(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::AddResponseMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AddResponseMessage>> Asyncadd_data(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AddResponseMessage>>(Asyncadd_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AddResponseMessage>> PrepareAsyncadd_data(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AddResponseMessage>>(PrepareAsyncadd_dataRaw(context, request, cq));
    }
    ::grpc::Status delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::DeleteResponseMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DeleteResponseMessage>> Asyncdelete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DeleteResponseMessage>>(Asyncdelete_dataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DeleteResponseMessage>> PrepareAsyncdelete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DeleteResponseMessage>>(PrepareAsyncdelete_dataRaw(context, request, cq));
    }
    ::grpc::Status show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::ShowAllResponseMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ShowAllResponseMessage>> Asyncshow_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ShowAllResponseMessage>>(Asyncshow_allRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ShowAllResponseMessage>> PrepareAsyncshow_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ShowAllResponseMessage>>(PrepareAsyncshow_allRaw(context, request, cq));
    }
    ::grpc::Status RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::RandomGenerateDBResponseMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RandomGenerateDBResponseMessage>> AsyncRanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RandomGenerateDBResponseMessage>>(AsyncRanGenDBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RandomGenerateDBResponseMessage>> PrepareAsyncRanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RandomGenerateDBResponseMessage>>(PrepareAsyncRanGenDBRaw(context, request, cq));
    }
    ::grpc::Status DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::DestroyResponseMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DestroyResponseMessage>> AsyncDestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DestroyResponseMessage>>(AsyncDestroyDBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DestroyResponseMessage>> PrepareAsyncDestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DestroyResponseMessage>>(PrepareAsyncDestroyDBRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void setup(::grpc::ClientContext* context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setup(::grpc::ClientContext* context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setup(::grpc::ClientContext* context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void search(::grpc::ClientContext* context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void search(::grpc::ClientContext* context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void search(::grpc::ClientContext* context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void add_data(::grpc::ClientContext* context, const ::AddRequestMessage* request, ::AddResponseMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void add_data(::grpc::ClientContext* context, const ::AddRequestMessage* request, ::AddResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void add_data(::grpc::ClientContext* context, const ::AddRequestMessage* request, ::AddResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void delete_data(::grpc::ClientContext* context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void show_all(::grpc::ClientContext* context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RanGenDB(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DestroyDB(::grpc::ClientContext* context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::SetupResponseMessage>* AsyncsetupRaw(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SetupResponseMessage>* PrepareAsyncsetupRaw(::grpc::ClientContext* context, const ::SetupRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SearchResponseMessage>* AsyncsearchRaw(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SearchResponseMessage>* PrepareAsyncsearchRaw(::grpc::ClientContext* context, const ::SearchRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AddResponseMessage>* Asyncadd_dataRaw(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AddResponseMessage>* PrepareAsyncadd_dataRaw(::grpc::ClientContext* context, const ::AddRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DeleteResponseMessage>* Asyncdelete_dataRaw(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DeleteResponseMessage>* PrepareAsyncdelete_dataRaw(::grpc::ClientContext* context, const ::DeleteRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ShowAllResponseMessage>* Asyncshow_allRaw(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ShowAllResponseMessage>* PrepareAsyncshow_allRaw(::grpc::ClientContext* context, const ::ShowAllRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RandomGenerateDBResponseMessage>* AsyncRanGenDBRaw(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RandomGenerateDBResponseMessage>* PrepareAsyncRanGenDBRaw(::grpc::ClientContext* context, const ::RandomGenerateDBRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DestroyResponseMessage>* AsyncDestroyDBRaw(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DestroyResponseMessage>* PrepareAsyncDestroyDBRaw(::grpc::ClientContext* context, const ::DestroyRequestMessage& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_setup_;
    const ::grpc::internal::RpcMethod rpcmethod_search_;
    const ::grpc::internal::RpcMethod rpcmethod_add_data_;
    const ::grpc::internal::RpcMethod rpcmethod_delete_data_;
    const ::grpc::internal::RpcMethod rpcmethod_show_all_;
    const ::grpc::internal::RpcMethod rpcmethod_RanGenDB_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyDB_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status setup(::grpc::ServerContext* context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response);
    virtual ::grpc::Status search(::grpc::ServerContext* context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response);
    virtual ::grpc::Status add_data(::grpc::ServerContext* context, const ::AddRequestMessage* request, ::AddResponseMessage* response);
    virtual ::grpc::Status delete_data(::grpc::ServerContext* context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response);
    virtual ::grpc::Status show_all(::grpc::ServerContext* context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response);
    virtual ::grpc::Status RanGenDB(::grpc::ServerContext* context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response);
    virtual ::grpc::Status DestroyDB(::grpc::ServerContext* context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setup() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setup(::grpc::ServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsetup(::grpc::ServerContext* context, ::SetupRequestMessage* request, ::grpc::ServerAsyncResponseWriter< ::SetupResponseMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_search() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status search(::grpc::ServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsearch(::grpc::ServerContext* context, ::SearchRequestMessage* request, ::grpc::ServerAsyncResponseWriter< ::SearchResponseMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_add_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_add_data() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_add_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_data(::grpc::ServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_data(::grpc::ServerContext* context, ::AddRequestMessage* request, ::grpc::ServerAsyncResponseWriter< ::AddResponseMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_delete_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_delete_data() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_delete_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delete_data(::grpc::ServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdelete_data(::grpc::ServerContext* context, ::DeleteRequestMessage* request, ::grpc::ServerAsyncResponseWriter< ::DeleteResponseMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_show_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_show_all() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_show_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status show_all(::grpc::ServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestshow_all(::grpc::ServerContext* context, ::ShowAllRequestMessage* request, ::grpc::ServerAsyncResponseWriter< ::ShowAllResponseMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RanGenDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RanGenDB() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_RanGenDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RanGenDB(::grpc::ServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRanGenDB(::grpc::ServerContext* context, ::RandomGenerateDBRequestMessage* request, ::grpc::ServerAsyncResponseWriter< ::RandomGenerateDBResponseMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyDB() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DestroyDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyDB(::grpc::ServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyDB(::grpc::ServerContext* context, ::DestroyRequestMessage* request, ::grpc::ServerAsyncResponseWriter< ::DestroyResponseMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_setup<WithAsyncMethod_search<WithAsyncMethod_add_data<WithAsyncMethod_delete_data<WithAsyncMethod_show_all<WithAsyncMethod_RanGenDB<WithAsyncMethod_DestroyDB<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::SetupRequestMessage, ::SetupResponseMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SetupRequestMessage* request, ::SetupResponseMessage* response) { return this->setup(context, request, response); }));}
    void SetMessageAllocatorFor_setup(
        ::grpc::experimental::MessageAllocator< ::SetupRequestMessage, ::SetupResponseMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SetupRequestMessage, ::SetupResponseMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setup(::grpc::ServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setup(
      ::grpc::CallbackServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_search() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::SearchRequestMessage, ::SearchResponseMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::SearchRequestMessage* request, ::SearchResponseMessage* response) { return this->search(context, request, response); }));}
    void SetMessageAllocatorFor_search(
        ::grpc::experimental::MessageAllocator< ::SearchRequestMessage, ::SearchResponseMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::SearchRequestMessage, ::SearchResponseMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status search(::grpc::ServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* search(
      ::grpc::CallbackServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* search(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_add_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_add_data() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::AddRequestMessage, ::AddResponseMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::AddRequestMessage* request, ::AddResponseMessage* response) { return this->add_data(context, request, response); }));}
    void SetMessageAllocatorFor_add_data(
        ::grpc::experimental::MessageAllocator< ::AddRequestMessage, ::AddResponseMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::AddRequestMessage, ::AddResponseMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_add_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_data(::grpc::ServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* add_data(
      ::grpc::CallbackServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* add_data(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_delete_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_delete_data() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::DeleteRequestMessage, ::DeleteResponseMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::DeleteRequestMessage* request, ::DeleteResponseMessage* response) { return this->delete_data(context, request, response); }));}
    void SetMessageAllocatorFor_delete_data(
        ::grpc::experimental::MessageAllocator< ::DeleteRequestMessage, ::DeleteResponseMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::DeleteRequestMessage, ::DeleteResponseMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_delete_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delete_data(::grpc::ServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* delete_data(
      ::grpc::CallbackServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* delete_data(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_show_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_show_all() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::ShowAllRequestMessage, ::ShowAllResponseMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::ShowAllRequestMessage* request, ::ShowAllResponseMessage* response) { return this->show_all(context, request, response); }));}
    void SetMessageAllocatorFor_show_all(
        ::grpc::experimental::MessageAllocator< ::ShowAllRequestMessage, ::ShowAllResponseMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ShowAllRequestMessage, ::ShowAllResponseMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_show_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status show_all(::grpc::ServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* show_all(
      ::grpc::CallbackServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* show_all(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RanGenDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RanGenDB() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::RandomGenerateDBRequestMessage, ::RandomGenerateDBResponseMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::RandomGenerateDBRequestMessage* request, ::RandomGenerateDBResponseMessage* response) { return this->RanGenDB(context, request, response); }));}
    void SetMessageAllocatorFor_RanGenDB(
        ::grpc::experimental::MessageAllocator< ::RandomGenerateDBRequestMessage, ::RandomGenerateDBResponseMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RandomGenerateDBRequestMessage, ::RandomGenerateDBResponseMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RanGenDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RanGenDB(::grpc::ServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RanGenDB(
      ::grpc::CallbackServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RanGenDB(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DestroyDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DestroyDB() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::DestroyRequestMessage, ::DestroyResponseMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::DestroyRequestMessage* request, ::DestroyResponseMessage* response) { return this->DestroyDB(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyDB(
        ::grpc::experimental::MessageAllocator< ::DestroyRequestMessage, ::DestroyResponseMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::DestroyRequestMessage, ::DestroyResponseMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DestroyDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyDB(::grpc::ServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DestroyDB(
      ::grpc::CallbackServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DestroyDB(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_setup<ExperimentalWithCallbackMethod_search<ExperimentalWithCallbackMethod_add_data<ExperimentalWithCallbackMethod_delete_data<ExperimentalWithCallbackMethod_show_all<ExperimentalWithCallbackMethod_RanGenDB<ExperimentalWithCallbackMethod_DestroyDB<Service > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_setup<ExperimentalWithCallbackMethod_search<ExperimentalWithCallbackMethod_add_data<ExperimentalWithCallbackMethod_delete_data<ExperimentalWithCallbackMethod_show_all<ExperimentalWithCallbackMethod_RanGenDB<ExperimentalWithCallbackMethod_DestroyDB<Service > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setup() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setup(::grpc::ServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_search() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status search(::grpc::ServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_add_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_add_data() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_add_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_data(::grpc::ServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_delete_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_delete_data() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_delete_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delete_data(::grpc::ServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_show_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_show_all() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_show_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status show_all(::grpc::ServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RanGenDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RanGenDB() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_RanGenDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RanGenDB(::grpc::ServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyDB() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DestroyDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyDB(::grpc::ServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setup() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setup(::grpc::ServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsetup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_search() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status search(::grpc::ServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsearch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_add_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_add_data() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_add_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_data(::grpc::ServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestadd_data(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_delete_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_delete_data() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_delete_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delete_data(::grpc::ServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdelete_data(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_show_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_show_all() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_show_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status show_all(::grpc::ServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestshow_all(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RanGenDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RanGenDB() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_RanGenDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RanGenDB(::grpc::ServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRanGenDB(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyDB() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DestroyDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyDB(::grpc::ServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyDB(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setup(::grpc::ServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_search() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->search(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status search(::grpc::ServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* search(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* search(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_add_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_add_data() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->add_data(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_add_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status add_data(::grpc::ServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* add_data(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* add_data(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_delete_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_delete_data() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->delete_data(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_delete_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delete_data(::grpc::ServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* delete_data(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* delete_data(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_show_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_show_all() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->show_all(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_show_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status show_all(::grpc::ServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* show_all(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* show_all(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RanGenDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RanGenDB() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RanGenDB(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RanGenDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RanGenDB(::grpc::ServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RanGenDB(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RanGenDB(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DestroyDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DestroyDB() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyDB(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DestroyDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyDB(::grpc::ServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DestroyDB(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DestroyDB(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setup() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SetupRequestMessage, ::SetupResponseMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SetupRequestMessage, ::SetupResponseMessage>* streamer) {
                       return this->Streamedsetup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setup(::grpc::ServerContext* /*context*/, const ::SetupRequestMessage* /*request*/, ::SetupResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsetup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SetupRequestMessage,::SetupResponseMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_search : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_search() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::SearchRequestMessage, ::SearchResponseMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::SearchRequestMessage, ::SearchResponseMessage>* streamer) {
                       return this->Streamedsearch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_search() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status search(::grpc::ServerContext* /*context*/, const ::SearchRequestMessage* /*request*/, ::SearchResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsearch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::SearchRequestMessage,::SearchResponseMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_add_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_add_data() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::AddRequestMessage, ::AddResponseMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::AddRequestMessage, ::AddResponseMessage>* streamer) {
                       return this->Streamedadd_data(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_add_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status add_data(::grpc::ServerContext* /*context*/, const ::AddRequestMessage* /*request*/, ::AddResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedadd_data(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AddRequestMessage,::AddResponseMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_delete_data : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_delete_data() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::DeleteRequestMessage, ::DeleteResponseMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::DeleteRequestMessage, ::DeleteResponseMessage>* streamer) {
                       return this->Streameddelete_data(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_delete_data() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status delete_data(::grpc::ServerContext* /*context*/, const ::DeleteRequestMessage* /*request*/, ::DeleteResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddelete_data(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::DeleteRequestMessage,::DeleteResponseMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_show_all : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_show_all() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ShowAllRequestMessage, ::ShowAllResponseMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ShowAllRequestMessage, ::ShowAllResponseMessage>* streamer) {
                       return this->Streamedshow_all(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_show_all() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status show_all(::grpc::ServerContext* /*context*/, const ::ShowAllRequestMessage* /*request*/, ::ShowAllResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedshow_all(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ShowAllRequestMessage,::ShowAllResponseMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RanGenDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RanGenDB() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RandomGenerateDBRequestMessage, ::RandomGenerateDBResponseMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RandomGenerateDBRequestMessage, ::RandomGenerateDBResponseMessage>* streamer) {
                       return this->StreamedRanGenDB(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RanGenDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RanGenDB(::grpc::ServerContext* /*context*/, const ::RandomGenerateDBRequestMessage* /*request*/, ::RandomGenerateDBResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRanGenDB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RandomGenerateDBRequestMessage,::RandomGenerateDBResponseMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyDB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyDB() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::DestroyRequestMessage, ::DestroyResponseMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::DestroyRequestMessage, ::DestroyResponseMessage>* streamer) {
                       return this->StreamedDestroyDB(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyDB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyDB(::grpc::ServerContext* /*context*/, const ::DestroyRequestMessage* /*request*/, ::DestroyResponseMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyDB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::DestroyRequestMessage,::DestroyResponseMessage>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_setup<WithStreamedUnaryMethod_search<WithStreamedUnaryMethod_add_data<WithStreamedUnaryMethod_delete_data<WithStreamedUnaryMethod_show_all<WithStreamedUnaryMethod_RanGenDB<WithStreamedUnaryMethod_DestroyDB<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_setup<WithStreamedUnaryMethod_search<WithStreamedUnaryMethod_add_data<WithStreamedUnaryMethod_delete_data<WithStreamedUnaryMethod_show_all<WithStreamedUnaryMethod_RanGenDB<WithStreamedUnaryMethod_DestroyDB<Service > > > > > > > StreamedService;
};


#endif  // GRPC_rpc_2eproto__INCLUDED
